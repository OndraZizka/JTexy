package cz.dynawest.jtexy;

/**
 * Texy! - Convert plain text to XHTML format using {@link process()}.
 *
 * This was a try to rewrite the PHP classes blindly. No way.
 *
 * <code>
 *     _SS_texy = new Texy();
 *     _SS_html = _SS_texy.process(_SS_text);
 * </code>
 *
 ** @author Ondrej Zizka
 * @copyright  Copyright (c) 2004, 2008 David Grudl
 * @package    Texy
 */
public class JTexy1 /*extends Nette::Object*/ {
    // configuration directives
    public static final boolean ALL = true;
    public static final boolean NONE = false;

    // Texy version
    public static final String VERSION = "0.0";
    public static final String REVISION = "1 released on 2008/08/20 22:03:00";

    // types of protection marks
    public static final String CONTENT_MARKUP = "\u0017";
    public static final String CONTENT_REPLACED = "\u0016";
    public static final String CONTENT_TEXTUAL = "\u0015";
    public static final String CONTENT_BLOCK = "\u0014";

    // url filters
    public static final String FILTER_ANCHOR = "anchor";
    public static final String FILTER_IMAGE = "image";

    // HTML minor-modes
    public static final String XML = 2;

    // HTML modes
    public enum HtmlMode {
        HTML4_TRANSITIONAL(0),
        HTML4_STRICT(1),
        HTML5(4),
        XHTML1_TRANSITIONAL(2), // JTexy.HTML4_TRANSITIONAL | JTexy.XML;
        XHTML1_STRICT(3), // JTexy.HTML4_STRICT | JTexy.XML;
        XHTML5(6), // JTexy.HTML5 | JTexy.XML;
    }

    /** @var string  input & output text encoding */
    public String encoding = "utf-8";

    /** @var array  Texy! syntax configuration */
    public Map<String, Boolean> allowed = new HashMap();

    /** @var TRUE|FALSE|array  Allowed HTML tags */
    public List<String> allowedTags;

    /** @var TRUE|FALSE|array  Allowed classes */
    public boolean allowedClasses = JTexy1.ALL; // all classes and id are allowed

    /** @var TRUE|FALSE|array  Allowed inline CSS style */
    public boolean allowedStyles = JTexy1.ALL;  // all inline styles are allowed

    /** @var int  TAB width (for converting tabs to spaces) */
    public int tabWidth = 8;

    /** @var boolean  Do obfuscate e-mail addresses? */
    public boolean obfuscateEmail = true;

    /** @var array  regexps to check URL schemes */
    public boolean urlSchemeFilters = null; // disable URL scheme filter

    /** @var bool  Paragraph merging mode */
    public boolean mergeLines = true;

    /** @var array  Parsing summary */
    public class ParsingSummary{
        public List images = new ArrayList();
        public List links = new ArrayList();
        public List preload = new ArrayList();
    }
    public ParsingSummary summary = new ParsingSummary();

    /** @var string  Generated stylesheet */
    public String styleSheet = "";

    /** @var array  CSS classes for align modifiers */
    public Map<String, String> alignClasses = new HashMap();
  /*(
		"left" => NULL,
		"right" => NULL,
		"center" => NULL,
		"justify" => NULL,
		"top" => NULL,
		"middle" => NULL,
		"bottom" => NULL,
	);/**/

    /** @var bool  remove soft hyphens (SHY)? */
    public boolean removeSoftHyphens = true;

    /** @var mixed */
    //public static advertisingNotice = "once";

    /** @var string */
    public String nontextParagraph = "div";

    /** @var TexyScriptModule */
    public Module scriptModule;

    /** @var TexyParagraphModule */
    public Module paragraphModule;

    /** @var TexyHtmlModule */
    public Module htmlModule;

    /** @var TexyImageModule */
    public Module imageModule;

    /** @var TexyLinkModule */
    public Module linkModule;

    /** @var TexyPhraseModule */
    public Module phraseModule;

    /** @var TexyEmoticonModule */
    public Module emoticonModule;

    /** @var TexyBlockModule */
    public Module blockModule;

    /** @var TexyHeadingModule */
    public Module headingModule;

    /** @var TexyHorizLineModule */
    public Module horizLineModule;

    /** @var TexyBlockQuoteModule */
    public Module blockQuoteModule;

    /** @var TexyListModule */
    public Module listModule;

    /** @var TexyTableModule */
    public Module tableModule;

    /** @var TexyFigureModule */
    public Module figureModule;

    /** @var TexyTypographyModule */
    public Module typographyModule;

    /** @var TexyLongWordsModule */
    public Module longWordsModule;

    /** @var TexyHtmlOutputModule */
    public Module htmlOutputModule;


    /**
     * Registered regexps and associated handlers for inline parsing.
     * @var array of ("handler" => callback
     *                "pattern" => regular expression)
     */
    private Map<String, PatternHandler> linePatterns = new HashMap();
    private _SS__linePatterns;

    /**
     * Registered regexps and associated handlers for block parsing.
     * @var array of ("handler" => callback
     *                "pattern" => regular expression)
     */
    private Map<String, PatternHandler> blockPatterns = new HashMap();
    private _SS__blockPatterns;

    /** @var array */
    private Map<String, PatternHandler> postHandlers = new HashMap();

    /** @var TexyHtml DOM structure for parsed text */
    private _SS_DOM;

    /** @var array  Texy protect markup table */
    private _SS_marks = ArrayList();

    /** @var array  for internal usage */
    public _SS__classes, _SS__styles;

    /** @var bool */
    private boolean processing;

    /** @var array of events and registered handlers */
    private _SS_handlers = array();

    /**
     * DTD descriptor.
     *   _SS_dtd[element][0] - allowed attributes (as array keys)
     *   _SS_dtd[element][1] - allowed content for an element (content model) (as array keys)
     *                    - array of allowed elements (as keys)
     *                    - FALSE - empty element
     *                    - 0 - special case for ins & del
     * @var array
     */
    public _SS_dtd;

    /** @var array */
    private static _SS_dtdCache;

    /** @var int  HTML mode */
    private _SS_mode;


    /** DEPRECATED */
    public static Object strictDTD;
    public Module cleaner;
    public Object xhtml;



    public JTexy1()
    {
        // load all modules
        this.loadModules();

        // DEPRECATED
        if (JTexy1.strictDTD != NULL) {
            this.setOutputMode(JTexy1.strictDTD ? JTexy1.HtmlMode.XHTML1_STRICT : JTexy1.HtmlMode.XHTML1_TRANSITIONAL);
        } else {
            this.setOutputMode(JTexy1.HtmlMode.XHTML1_TRANSITIONAL);
        }

        // DEPRECATED
        this.cleaner = this.htmlOutputModule;

        // examples of link references ;-)
        TexyLink link = new TexyLink("http://texy.info/");
        link.modifier.title = "The best text to HTML converter and formatter";
        link.label = "Texy!";
        this.linkModule.addReference("texy", _SS_link);

        link = new TexyLink("http://www.google.com/search?q=%s");
        this.linkModule.addReference("google", _SS_link);

        link = new TexyLink("http://en.wikipedia.org/wiki/Special:Search?search=%s");
        this.linkModule.addReference("wikipedia", _SS_link);
    }



    /**
     * Set HTML/XHTML output mode (overwrites JTexy.allowedTags)
     * @param  int
     * @return void
     */
    public void setOutputMode(JTexy1.HtmlMode mode)
    {


		/*if (!isset(JTexy.dtdCache[_SS_mode])) {
			require dirname(__FILE__) . "/libs/DTD.php";
			JTexy.dtdCache[_SS_mode] = _SS_dtd;
		}*/

        this.mode = _SS_mode;
        this.dtd = JTexy1.dtdCache[_SS_mode];
        TexyHtml::_SS_xhtml = (boolean) (_SS_mode & JTexy1.XML); // TODO: remove?

        // accept all valid HTML tags and attributes by default
        this.allowedTags = array();
        foreach (this.dtd as _SS_tag => _SS_dtd) {
        this.allowedTags[_SS_tag] = JTexy1.ALL;
    }
    }



    /**
     * Get HTML/XHTML output mode
     * @return int
     */
    public JTexy1.HtmlMode getOutputMode()
    {
        return this.mode;
    }



    /**
     * Create array of all used modules (this.modules).
     * This array can be changed by overriding this method (by subclasses)
     */
    protected void loadModules()
    {
        // line parsing
        this.scriptModule = new TexyScriptModule(this);
        this.htmlModule = new TexyHtmlModule(this);
        this.imageModule = new TexyImageModule(this);
        this.phraseModule = new TexyPhraseModule(this);
        this.linkModule = new TexyLinkModule(this);
        this.emoticonModule = new TexyEmoticonModule(this);

        // block parsing
        this.paragraphModule = new TexyParagraphModule(this);
        this.blockModule = new TexyBlockModule(this);
        this.figureModule = new TexyFigureModule(this);
        this.horizLineModule = new TexyHorizLineModule(this);
        this.blockQuoteModule = new TexyBlockQuoteModule(this);
        this.tableModule = new TexyTableModule(this);
        this.headingModule = new TexyHeadingModule(this);
        this.listModule = new TexyListModule(this);

        // post process
        this.typographyModule = new TexyTypographyModule(this);
        this.longWordsModule = new TexyLongWordsModule(this);
        this.htmlOutputModule = new TexyHtmlOutputModule(this);
    }



    class PatternHandler{
        String name;
        Handler handler;
        Pattern pattern;

        public PatternHandler( String name, Handler handler, Pattern pattern ) {
            this.name = name;
            this.handler = handler;
            this.pattern = pattern;
        }

    }


    public final void registerLinePattern(Handler handler, Pattern pattern, String name )
    {
        if( !this.allowed.containsKey(name)) this.allowed.put(name, true);

        this.linePatterns.put(name, new PatternHandler( name, handler, pattern ));
    }



    public final void registerBlockPattern(Handler handler, Pattern pattern, String name )
    {
        // if (!preg_match("#(.)\^.*\_SS_\\1[a-z]*#is", _SS_pattern)) die("Texy: Not a block pattern _SS_name");

        if( !this.allowed.containsKey(name)) this.allowed.put(name, true);

        this.blockPatterns.put(name, new PatternHandler( name, handler, pattern+"m" )); // force multiline
    }



    public final void registerPostLine( Handler handler, String name )
    {
        if( !this.allowed.containsKey(name)) this.allowed.put(name, true);

        this.postHandlers[_SS_name] = _SS_handler;
    }



    /**
     * Convert Texy! document in (X)HTML code.
     *
     * @param  string   input text
     * @param  bool     is block or single line?
     * @return string  output html code
     */
    public void process( String text, boolean singleLine ) throws TexyException
    {
        if (this.processing) {
            throw new InvalidStateException("Processing is in progress yet.");
        }

        // initialization
        this.marks = array();
        this.processing = true;

        // speed-up (d)
        if (is_array(this.allowedClasses)) this._classes = array_flip(this.allowedClasses);
        else this._classes = this.allowedClasses;

        if (is_array(this.allowedStyles)) this._styles = array_flip(this.allowedStyles);
        else this._styles = this.allowedStyles;

        // convert to UTF-8 (and check source encoding)
        text = TexyUtf::toUtf(_SS_text, this.encoding);

        if (this.removeSoftHyphens) {
            text = text.replace( "\u00C2", "" ).replace("\u00AD", "");
        }

        // standardize line endings and spaces
        text = JTexy1.normalize(text);

        // replace tabs with spaces
        this.tabWidth = Math.max(1, this.tabWidth);
        while( text.indexOf("\t") != -1 ){
            text = preg_replace_callback("#^(.*)\t#mU", array(this, "tabCb"), _SS_text);
        }

        // user before handler
        this.invokeHandlers("beforeParse", array(this, text, singleLine));

        // select patterns
        this._linePatterns = this.linePatterns;
        this._blockPatterns = this.blockPatterns;
        foreach (this._linePatterns as _SS_name => _SS_foo) {
            if (empty(this.allowed[_SS_name])) unset(this._linePatterns[_SS_name]);
        }
        foreach (this._blockPatterns as _SS_name => _SS_foo) {
            if (empty(this.allowed[_SS_name])) unset(this._blockPatterns[_SS_name]);
        }

        // parse Texy! document into internal DOM structure
        this.DOM = TexyHtml::el();
        if (_SS_singleLine) {
            this.DOM.parseLine(this, _SS_text);
        } else {
            this.DOM.parseBlock(this, _SS_text);
        }

        // user after handler
        this.invokeHandlers("afterParse", array(this, this.DOM, _SS_singleLine));

        // converts internal DOM structure to final HTML code
        _SS_html = this.DOM.toHtml(this);

        // this notice should remain
        if (JTexy1.advertisingNotice) {
            _SS_html .= "\n<!-- by Texy2! -.";
            if (JTexy1.advertisingNotice === "once") {
                JTexy1.advertisingNotice = FALSE;
            }
        }

        this.processing = FALSE;

        return TexyUtf::utf2html(_SS_html, this.encoding);
    }



    /**
     * Makes only typographic corrections.
     * @param  string   input text
     * @return string  output code (in UTF!)
     */
    public String processTypo( String text )
    {
        // convert to UTF-8 (and check source encoding)
        text = TexyUtf::toUtf(text, this.encoding);

        // standardize line endings and spaces
        text = JTexy1.normalize(text);

        this.typographyModule.beforeParse(this, text);
        text = this.typographyModule.postLine(text);

        return TexyUtf::utf2html(text, this.encoding);
    }



    /**
     * Converts DOM structure to pure text.
     * @return string
     */
    public String toText()
    {
        if (!this.DOM) {
            throw new InvalidStateException("Call _SS_texy.process() first.");
        }

        return TexyUtf::utfTo(this.DOM.toText(this), this.encoding);
    }



    /**
     * Converts internal string representation to final HTML code in UTF-8.
     * @return string
     */
    public final String stringToHtml( String s)
    {
        // decode HTML entities to UTF-8
        s = JTexy1.unescapeHtml(s);

        // line-postprocessing
        String[] blocks = s.split(JTexy1.CONTENT_BLOCK);
        foreach (this.postHandlers as _SS_name => _SS_handler) {
        if (empty(this.allowed[_SS_name])) continue;
        foreach (_SS_blocks as _SS_n => _SS_s) {
            if (_SS_n % 2 === 0 && _SS_s !== "") {
                _SS_blocks[_SS_n] = call_user_func(_SS_handler, _SS_s);
            }
        }
    }
        s = HelperFunctions.join( blocks, JTexy1.CONTENT_BLOCK);

        // encode < > &
        s = JTexy1.escapeHtml(s);

        // replace protected marks
        s = this.unProtect(s);

        // wellform and reformat HTML
        this.invokeHandlers("postProcess", array(this, s));

        // unfreeze spaces
        s = JTexy1.unfreezeSpaces(s);

        return _SS_s;
    }



    /**
     * Converts internal string representation to final HTML code in UTF-8.
     * @return string
     */
    final public function stringToText(_SS_s)
    {
        _SS_save = this.htmlOutputModule.lineWrap;
        this.htmlOutputModule.lineWrap = FALSE;
        _SS_s = this.stringToHtml( _SS_s );
        this.htmlOutputModule.lineWrap = _SS_save;

        // remove tags
        _SS_s = preg_replace("#<(script|style)(.*)</\\1>#Uis", "", _SS_s);
        _SS_s = strip_tags(_SS_s);
        _SS_s = preg_replace("#\n\s*\n\s*\n[\n\s]*\n#", "\n\n", _SS_s);

        // entities . chars
        _SS_s = JTexy1.unescapeHtml(_SS_s);

        // convert nbsp to normal space and remove shy
        _SS_s = strtr(_SS_s, array(
                        "\xC2\xAD" => "",  // shy
                "\xC2\xA0" => " ", // nbsp
		));

        return _SS_s;
    }



    /**
     * Add new event handler.
     *
     * @param  string   event name
     * @param  callback
     * @return void
     */
    final public function addHandler(_SS_event, _SS_callback)
    {
        if (!is_callable(_SS_callback)) {
            throw new InvalidArgumentException("Invalid callback.");
        }

        this.handlers[_SS_event][] = _SS_callback;
    }



    /**
     * Invoke registered around-handlers.
     *
     * @param  string   event name
     * @param  TexyParser  actual parser object
     * @param  array    arguments passed into handler
     * @return mixed
     */
    final public function invokeAroundHandlers(_SS_event, _SS_parser, _SS_args)
    {
        if (!isset(this.handlers[_SS_event])) return FALSE;

        _SS_invocation = new TexyHandlerInvocation(this.handlers[_SS_event], _SS_parser, _SS_args);
        _SS_res = _SS_invocation.proceed();
        _SS_invocation.free();
        return _SS_res;
    }



    /**
     * Invoke registered after-handlers.
     *
     * @param  string   event name
     * @param  array    arguments passed into handler
     * @return void
     */
    final public function invokeHandlers(_SS_event, _SS_args)
    {
        if (!isset(this.handlers[_SS_event])) return;

        foreach (this.handlers[_SS_event] as _SS_handler) {
        call_user_func_array(_SS_handler, _SS_args);
    }
    }



    /**
     * Translate all white spaces (\t \n \r space) to meta-spaces \x01-\x04.
     * which are ignored by TexyHtmlOutputModule routine
     * @param  string
     * @return string
     */
    final public static function freezeSpaces(_SS_s)
    {
        return strtr(_SS_s, " \t\r\n", "\x01\x02\x03\x04");
    }



    /**
     * Reverts meta-spaces back to normal spaces.
     * @param  string
     * @return string
     */
    final public static function unfreezeSpaces(_SS_s)
    {
        return strtr(_SS_s, "\x01\x02\x03\x04", " \t\r\n");
    }



    /**
     * Removes special controls characters and normalizes line endings and spaces.
     * @param  string
     * @return string
     */
    final public static function normalize(_SS_s)
    {
        // standardize line endings to unix-like
        _SS_s = str_replace("\r\n", "\n", _SS_s); // DOS
        _SS_s = strtr(_SS_s, "\r", "\n"); // Mac

        // remove special chars; leave \t + \n
        _SS_s = preg_replace("#[\x00-\x08\x0B-\x1F]+#", "", _SS_s);

        // right trim
        _SS_s = preg_replace("#[\t ]+_SS_#m", "", _SS_s);

        // trailing spaces
        _SS_s = trim(_SS_s, "\n");

        return _SS_s;
    }



    /**
     * Converts to web safe characters [a-z0-9-] text.
     * @param  string
     * @param  string
     * @return string
     */
    final public static function webalize(_SS_s, _SS_charlist = NULL)
    {
        _SS_s = TexyUtf::utf2ascii(_SS_s);
        _SS_s = strtolower(_SS_s);
        if (_SS_charlist) _SS_charlist = preg_quote(_SS_charlist, "#");
        _SS_s = preg_replace("#[^a-z0-9"._SS_charlist."]+#", "-", _SS_s);
        _SS_s = trim(_SS_s, "-");
        return _SS_s;
    }



    /**
     * Texy! version of htmlSpecialChars (much faster than htmlSpecialChars!).
     * note: &quot; is not encoded!
     * @param  string
     * @return string
     */
    final public static function escapeHtml(_SS_s)
    {
        return str_replace(array("&", "<", ">"), array("&amp;", "&lt;", "&gt;"), _SS_s);
    }



    /**
     * Texy! version of html_entity_decode (always UTF-8, much faster than original!).
     * @param  string
     * @return string
     */
    final public static function unescapeHtml(_SS_s)
    {
        if (strpos(_SS_s, "&") === FALSE) return _SS_s;
        return html_entity_decode(_SS_s, ENT_QUOTES, "UTF-8");
    }



    /**
     * Outdents text block.
     * @param  string
     * @return string
     */
    final public static function outdent(_SS_s)
    {
        _SS_s = trim(_SS_s, "\n");
        _SS_spaces = strspn(_SS_s, " ");
        if (_SS_spaces) return preg_replace("#^ {1,_SS_spaces}#m", "", _SS_s);
        return _SS_s;
    }



    /**
     * Generate unique mark - useful for freezing (folding) some substrings.
     * @param  string   any string to froze
     * @param  int      JTexy.CONTENT_* constant
     * @return string  internal mark
     */
    final public function protect(_SS_child, _SS_contentType)
    {
        if (_SS_child==="") return "";

        _SS_key = _SS_contentType
                . strtr(base_convert(count(this.marks), 10, 8), "01234567", "\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F")
                . _SS_contentType;

        this.marks[_SS_key] = _SS_child;

        return _SS_key;
    }



    final public function unProtect(_SS_html)
    {
        return strtr(_SS_html, this.marks);
    }



    /**
     * Filters bad URLs.
     * @param  string   user URL
     * @param  string   type: a-anchor, i-image, c-cite
     * @return bool
     */
    final public function checkURL(_SS_URL, _SS_type)
    {
        // absolute URL with scheme? check scheme!
        if (!empty(this.urlSchemeFilters[_SS_type])
                && preg_match("#".TEXY_URLSCHEME."#A", _SS_URL)
                && !preg_match(this.urlSchemeFilters[_SS_type], _SS_URL))
            return FALSE;

        return TRUE;
    }



    /**
     * Is given URL relative?
     * @param  string  URL
     * @return bool
     */
    final public static function isRelative(_SS_URL)
    {
        // check for scheme, or absolute path, or absolute URL
        return !preg_match("#".TEXY_URLSCHEME."|[\#/?]#A", _SS_URL);
    }



    /**
     * Prepends root to URL, if possible.
     * @param  string  URL
     * @param  string  root
     * @return string
     */
    final public static function prependRoot(_SS_URL, _SS_root)
    {
        if (_SS_root == NULL || !JTexy1.isRelative(_SS_URL)) return _SS_URL;
        return rtrim(_SS_root, "/\\") . "/" . _SS_URL;
    }

    final public function getLinePatterns()
    {
        return this._linePatterns;
    }
    final public function getBlockPatterns()
    {
        return this._blockPatterns;
    }
    final public function getDOM()
    {
        return this.DOM;
    }

    private String tabCb(_SS_m)
    {
        StringBuilder sb = new StringBuilder();

        return _SS_m[1] + str_repeat(" ", this.tabWidth - strlen(_SS_m[1]) % this.tabWidth);
    }


    final public __clone()
    {
        throw new NotSupportedException("Clone is not supported.");
    }

}
